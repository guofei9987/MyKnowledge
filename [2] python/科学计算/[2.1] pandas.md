<!-- TOC depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 -->

- [DataFrame](#dataframe)
	- [计算新列](#计算新列)
	- [index操作](#index操作)
		- [取index](#取index)
		- [设置index](#设置index)
		- [重设索引](#重设索引)
		- [自定义索引](#自定义索引)
- [index太多，默认填值为nan，可以ffill，bfill填充](#index太多默认填值为nan可以ffillbfill填充)
- [用指定的数填充](#用指定的数填充)
	- [重命名列](#重命名列)
	- [改变数据类型](#改变数据类型)
	- [计算Series每个值的频率](#计算series每个值的频率)
	- [字符串方法](#字符串方法)
- [sort](#sort)
- [index和字段修改](#index和字段修改)
- [列变化](#列变化)
	- [方法1：map](#方法1map)
- [my_dict是一个字典，key是data['food']中的元素，values是输出Series中的元素](#mydict是一个字典key是datafood中的元素values是输出series中的元素)
	- [方法2：apply](#方法2apply)
- [列筛选（bool类型）](#列筛选bool类型)
- [groupby](#groupby)
- [时间序列](#时间序列)
- [index](#index)
- [暂时没有学的](#暂时没有学的)

<!-- /TOC -->





```python
obj = pd.Series([4, 7, -5, 3])
pd.Series([1., 2., 3.], index=['a', 'b', 'c'])#赋上一个index，默认是0,1,2
```

# DataFrame




## 计算新列

```python
d=np.array([[1,2,3],[4,5,6]])
df=pd.DataFrame(d,index=['a','b'],columns=['c','d','e'])
df['f']=df['c']*2+df['d']+1
```

## index操作
### 取index

```py
df.index
df.columns
df.index.values
df.columns.values
df.index.name='idx'#设置index的名称
```

### 设置index
```python
a=df.set_index('one')
```
效果：
- 把one这一列变成index，并删除one这一列，结果保存在a中。
- 不改变df
- 不共享内存

### 重设索引

```python
df.reset_index(inplace=True)
```
使得索引变成一列，0,1,2,3...变成索引

### 自定义索引
reindex
```py
import pandas as pd
df=pd.DataFrame({'one':[1,2,3],'two':[7,6,5]},index=['a','b','c'])


df.reindex(list('abcde'),method='ffill')
#index太多，默认填值为nan，可以ffill，bfill填充

df.reindex(list('abcde'),fill_value=0)
#用指定的数填充
```
|参数|说明|
|--|--|
|index||
|method|ffill,bfill|
|fiil_value||
|limit|向前或向后填充时，最大填充量|
|copy|默认为True，否则不复制|

## 重命名列
```python
df.rename(columns={u'one':'1'}, inplace=True)#字典中可以放多个组
```

## 改变数据类型

```python
df1 = df[['two',]].astype('int')
```

## 计算Series每个值的频率
```
df['index'].value_counts()
```

## 字符串方法
```python
df['index'].str.upper()
df['index'].str.len()
df['index'].str.contains('a')#字符中是否包含a
```





```python
data.describe()
data.describe(include='all')
```
返回的是DataFrame格式的描述性统计数据

```
data.info()
```

# sort
排序
有inplace项
```python
data.sort_values(by=['group','ounces'], ascending=[False, True], inplace=True)
```




# index和字段修改




# 列变化

## 方法1：map

```python
data['animal'] = data['food'].map(str.lower).map(my_dict)
#my_dict是一个字典，key是data['food']中的元素，values是输出Series中的元素
```

## 方法2：apply

```python
data.apply(func1,axis='columns')#返回Series
```

func1的规则：
输入是一行
```python
def func1(series):
    #series的类型是Series，其内容是DataFrame的一行，
    #return内容就是data.apply这个series中的元素
```

# 列筛选（bool类型）




# groupby
```python
df.groupby('key1').max()#生成一个DataFrame，存入分组后每一列的最大值
```

分组求和
```python
df.groupby((df['key1'],df['key2'])).sum()
```
groupby后面可以接的方法：
```
sum mean median
count
size
```


Series后面可以接的方法
```python
value_counts()#与groupby.count的区别
cumsum
...(自己查)
```

# 时间序列
唯一的区别是index是time
```python
dates = pd.date_range('20130101',periods=6)
```
用以上方法生成时间序列后，可以用index=dates


# index


# 暂时没有学的

df.filter

```
data.group.groupby(data.group).count()
```
